1. private로 선언된 필드에 접근한 방법에 대해서 설명하세요.
	- getter, setter 메서드를 사용하여 접근한다.
	  getter 메서든느 private 필드 값을 읽을 때 사용한다.
	  setter 메서드는 private 필드 값을 변경할 때 사용한다.
	  이를 통해 캡슐화를 유지하며, 외부에서 필드에 직접 접근하지 못하도록 보호한다.



2. 기본형/참조형 매개변수와 기본형/참조형 반환타입에 대해서 설명하세요.  ( 개념 )
	- 기본형 매개변수 : 
		기본형 데이터를 메서드에 전달한다. 
		메서드 내부에서 값을 복사해 사용하므로 원래 값은 변경되지 않는다.
	- 참조형 매개변수 : 
		객체의 참조(주소)를 메서드에 전달한다. 
		메서드 내부에서 객체의 내용을 직접 변경할 수 있다.
	- 기본형 반환타입 : 
		메서드가 기본형 데이터를 반환한다.
	- 참조형 반환타입 : 
		메서드가 객체의 참조를 반환한다.
		반환된 참조를 통해 객체에 접근하거나 수정할 수 있다.



3. 생성자에 대해서 설명하세요.
	1) 일종의 메서드이다
	2) 리턴자료형이 없다.
	3) 클래스명 == 생성자명
	4) 디폴트 생성자(default constructor) : 매개변수 없는 생성자
	5) 메서드 호출 시기 : 인스턴스(객체) 생성하면 자동으로 호출되며, 인위적으로 생성자 호출은 안된다,
	6) 역할 : 필드 초기화
	7) modifier(접근 지정자) 사용가능
	8) 오버로딩(overloading) 가능
	9) 생성자는 상속되지 않는다.
	10) 클래스에 선언된 생성자가 하나도 없는 경우에는 컴파일러가 자동으로 디폴트 생성자를 생성한다.



4. this 키워드에 대해서 설명하세요.
	this는 현재 객체 자신을 참조하는 키워드로, 객체 내부에서 멤버(필드, 메서드 등)를 지칭하거나 생성자 호출에 사용된다.
	1) 멤버를 가리킬 때의 this
		- 지역 변수와 멤버 변수 이름이 같을 때, 멤버 변수를 명확히 구분하기 위해 사용된다.
	2) 생성자 안에서 또 다른 생성자를 호출하는 this 
		- 클래스의 다른 생성자를 호출할 때 사용한다. 이를 통해 생성자 코드를 재사용할 수 있다.
	3) 단독(홀로)으로 사용될 때의 this 
		- 현재 객체 자신을 반환하거나 현재 객체를 매개변수로 전달할 때 사용



5. 아래 코딩을 클래스( 객체) 배열 초기화를 사용해서 코딩하세요 
		Student s1 = new Student();
		Student s2 = new Student();
		Student s3 = new Student();

	Student [] student = {
			new Student(),
			new Student(),
			new Student(),
	};



6. 객체 복사(copy)와 객체 복제(clone)에 대해서 설명하세요.. 		
	- 객체 복사:  객체의 값(데이터)을 새로운 객체에 복사하는 것이다.
	- 객체 복제: 얕은 복제와 깊은 복제가 있다.
			얕은 복제는 객체의 필드 값을 복사하지만, 객체 내부에 참조 타입이 있다면 해당 참조는 공유된다.
			깊은 복제는 필드값뿐 아니라 참조된 객체도 새로운 객체로 복제한다.



7. 에러 메시지 : The constructor System() [is not visible] 에 대해서 설명하세요.
	- 인스턴스화할 수 없다는 오류이다. System 클래스는 인스턴스화할 수 없다.



8. [static 키워드]에 대해서 설명하세요. 
	- static 키워드는 클래스에 속하는 정적 필드 또는 정적 메서드를 선언할 때 사용된다.
	  static으로 선언된 필드와 메서드는 객체가 아닌 클래스 자체에 속하며, 인스턴스화하지 않아도 사용할 수 있다.
	  static 멤버는 프로그램 시작 시 '메서드 영역'에 로드된다.
	  주로 공통으로 사용되는 값이나 메서드를 정의할 때 사용된다.
	  객체 생성 없이 호출 가능하다.



9. "가변인자와 오버로딩"에 대해서 설명하세요.
 	- 가변인자는 매개변수의 갯수에 상관없이 타입... 변수명을 사용하여 선언할 수 있다.
	  매개변수의 갯수에 따라 모두 코딩할 필요없다는 장점이 있다. 
          매개변수 중 가장 뒤에 위치해야하며, 비효율적이기 때문에 최소한으로 사용하는 것이 좋다.
	  가변인자를 사용할 때도 오버로딩을 적용하여 코드를 간소화할 수 있다.



10. 아래 두 문자열의 대소문자 구분 없이, 순서 상관 없이 같은 문자여부를 체크하는 코딩을 하세요. 
	String n = "keNik";   
	String m= "kKnie";    
(전체 알고리즘 및 내용은 days13.Ex01파일)

	public static void main(String[] args) {
		String n = "keNik";   
		String m= "kKnie";    

		n = n.toUpperCase(); // "KENIK"	 ->	오름차순 정렬
		m = m.toUpperCase(); // "KKNIE"	 ->	오름차순 정렬

		n = stringSort(n);
		m = stringSort(m);
		System.out.println(n);
		System.out.println(m);

		if ( n.equals(m) ) {
			System.out.println( "같다" );
		} else { 
			System.out.println( "다르다" );
		}
	} // main

	private static String stringSort(String str) {
		char [] nArr = str.toCharArray();
		Arrays.sort( nArr );
		str = String.valueOf( nArr );
		return str;
	}




